[TASK]
help me improve my code and write new modules/functions

[PROGRAM DETAILS]
The program splits stems from various songs (with same BPM) into fragments, recombining them to make FRANKENSTEMS.

Currently, the program requires the stems to be added to the 'input' folder for the program to run. The current pipeline is as follows:

1. User provides songs as stems (that have suffix Vocals, Bass, Other, and Drums) 
2. Program asks user for desired Frankenstem length, recombination type (any combination of stems), and slicing type (by transients or by beats)
3. Program reads input files, calls 'splicer' module on relevant wav files, slicing them by slice type (stripping silence)
4. Program recombines the input files randomly from a combined array of fragments, until desired song length
5. Output is saved in output folder

[CHANGES TO IMPLEMENT]
1. clean up the user input 
2.
3.




[TASK]
Review my code and tell me what can be improved, without changing the functionality.

[PROGRAM DETAILS]
The program splits stems from various songs (with same BPM) into fragments, recombining them to make FRANKENSTEMS.

Currently, the program requires the stems to be added to the 'input' folder for the program to run. The current pipeline is as follows:

1. User provides songs as stems (that have suffix Vocals, Bass, Other, and Drums) 
2. Program asks user for desired Frankenstem length, recombination type (any combination of stems), and slicing type (by transients or by beats)
3. Program reads input files, calls 'splicer' module on relevant wav files, slicing them by slice type (stripping silence)
4. Program recombines the input files randomly from a combined array of fragments, until desired song length
5. Output is saved in output folder

[Main.py]
from frankenstem.audio_io import load_audio
from frankenstem.splicer import slice_into_random_beats, slice_by_transients
from frankenstem.combiner import combine_segments
from frankenstem.removing_silence import remove_silence
from frankenstem.filename_parser import load_wavs_from_folder
from frankenstem.classes import StemType, Song
import soundfile as sf
from datetime import datetime
from collections import defaultdict
import numpy as np
import random

INPUT_PATH = "input"
OUTPUT_PATH = "output"
BPM = 130
TARGET_DURATION_SECONDS = 20  #******ASK USER +++++ 

# load all .wav files from the input folder
stem_wavs = load_wavs_from_folder(INPUT_PATH)

# stem-type choices
stem_type_key = {
    "V": StemType.VOCALS,
    "B": StemType.BASS,
    "D": StemType.DRUMS,
    "O": StemType.OTHER
}

# slice-type choices
slice_type_key = {
    "R": slice_into_random_beats,
    "T": slice_by_transients
}

slice_params = {
    slice_into_random_beats: {"bpm": BPM},
    slice_by_transients: {"bpm":BPM, "delta": 0.01, "min_length_seconds": 0.5}#can be adjusted later to user input for delta
}

# ########CLEAN UP THIS SECTION FOR USER INPUT BY MOVING IT TO A FUNCTION !!!!!!!!!
#--- USER INPUT FOR TARGET DURATION ---
print(f"\n ---- WELCOME TO FRANKENSTEM! ----", end="\n\n")


while True:
    user_input = input("Enter target FRANKENSTEM duration in seconds (10-60 seconds, default 20): ") or "20"
    try:
        TARGET_DURATION_SECONDS = float(user_input)
        if 10 <= TARGET_DURATION_SECONDS <= 60:
            break
        else:
            print("Please enter a duration between 10 and 60 seconds.")
    except ValueError:
        print("Invalid input. Please enter a valid number in seconds.")

#--- USER INPUT FOR SOURCE BPM ---
while True:
    user_input = input("Enter source BPM ")
    try:
        BPM = float(user_input)
        if 20 <= BPM <= 300:
            break
        else:
            print("Please enter a BPM between 20 and 300.")
    except ValueError:
        print("Invalid input. Please enter a valid number.")
print(f"---- Target duration: {TARGET_DURATION_SECONDS} seconds, BPM: {BPM} ----", end="\n\n")

# --- USER INPUT FOR STEM TYPES ---
frankenstem_type_selection = input("List stem types to combine separated by commas:\nVOCALS = V\nBASS = B\nDRUMS = D\nOTHER = O\n(e.g. 'V,B,O'): ")
selected_keys = [s.strip().upper() for s in frankenstem_type_selection.split(",")]

try:
    selected_stem_types = [stem_type_key[k] for k in selected_keys]
except KeyError as e:
    raise ValueError(f"Invalid stem type selected: {e}")

print(f"---- Selected stem types: {[t.name for t in selected_stem_types]} ----", end="\n\n")


#--- USER INPUT FOR SLICE TYPE ---
while True:
    user_input = input("Select slice type:\nRANDOM BEATS = R\nTRANSIENTS = T\n(e.g. 'R'): ").strip().upper()
    if user_input in slice_type_key:
        selected_slicing_function = slice_type_key[user_input]
        break
    else:
        print("Please select a valid slice type (R or T).")
print(f"---- SLICE TYPE: {selected_slicing_function.__name__} ----\n")


# --- COLLECT SEGMENTS FROM SELECTED STEMS ---
all_segments = []
sr = None  # will be set after first audio load

for stem_type in selected_stem_types:
    for wav in stem_wavs:
        stem = wav.get_stem(stem_type)
        if not stem:
            continue

        audio, this_sr = stem.load_audio()

        if sr is None:
            sr = this_sr
        elif this_sr != sr:
            raise ValueError(f"Sample rate mismatch in stem: {stem.filepath}")

        # Dynamically call the selected slicing function with its params
        segments = selected_slicing_function(
            audio,
            sr,
            **slice_params[selected_slicing_function]
        )

        all_segments.extend(segments)

if len(all_segments) == 0:
    raise ValueError("No valid segments found for selected stem types.")

# --- SHUFFLE + SELECT SEGMENTS FOR DESIRED LENGTH ---
random.shuffle(all_segments)

# Estimate number of segments needed --!!!!!!!THIS NEEDS TO BE MADE MORE PRECISE!!!!!!!!!!!!
beats_per_second = BPM / 60
seconds_per_segment = 2  # average 2 beats per segment
estimated_segment_duration = seconds_per_segment / beats_per_second
num_segments = int(TARGET_DURATION_SECONDS / estimated_segment_duration)

selected_segments = all_segments[:num_segments]

# --- RECOMBINE + SAVE ---
frankenstem_audio = np.concatenate(selected_segments)
timestamp = datetime.now().strftime("%Y%m%d_%H%M")
stem_names = "_".join(stem_type.name.capitalize() for stem_type in selected_stem_types)
output_file = f"{OUTPUT_PATH}/FRANKENSTEM_{stem_names}_{timestamp}.wav"

sf.write(output_file, frankenstem_audio, sr)
print(f"Saved Frankenstem to {output_file}")
